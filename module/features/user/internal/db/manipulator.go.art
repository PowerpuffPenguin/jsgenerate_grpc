package db

import (
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	grpc_user "{{pkg}}/protocol/features/user"
	"strconv"
{{if !db}}
	"sort"
	"crypto/md5"
	"encoding/hex"
	"encoding/json"
	"{{pkg}}/utils"
	"strings"
	"sync"{{/if}}
)

{{if db}}
{{else}}
var _management = newManagement()

type dataSortByID []*Data

func (a dataSortByID) Len() int           { return len(a) }
func (a dataSortByID) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a dataSortByID) Less(i, j int) bool { return a[i].ID < a[j].ID }

type _Management struct {
	keys map[string]*Data
	sync.RWMutex
}

func newManagement() *_Management {
	return &_Management{
		keys: make(map[string]*Data),
	}
}

func (m *_Management) onReload(data json.RawMessage) (e error) {
	var items []Data
	e = json.Unmarshal(data, &items)
	if e != nil {
		return
	}
	m.Lock()
	for k := range m.keys {
		delete(m.keys, k)
	}
	for i := 0; i < len(items); i++ {
		item := &items[i]
		name := strings.ToLower(item.Name)
		if name == `` ||
			item.Password == `` ||
			!utils.MatchName(name) {
			continue
		}
		item.ID = int64(i)
		b := md5.Sum([]byte(item.Password))
		item.Password = hex.EncodeToString(b[:])
		m.keys[name] = item
	}
	m.Unlock()
	return
}

func (m *_Management) Find(request *grpc_user.FindRequest) (response *grpc_user.FindResponse, e error) {
	if request.Result < grpc_user.FindRequest_DATA ||
		request.Result > grpc_user.FindRequest_DATA_COUNT {
		e = status.Error(codes.InvalidArgument, `not support result enum : `+strconv.FormatInt(int64(request.Result), 10))
		return
	}
	findName := strings.ToLower(request.Name)
	var items []*Data
	m.RLock()
	for name, item := range m.keys {
		if request.Name != "" {
			if request.NameFuzzy {
				if !strings.Contains(name, findName) {
					continue
				}
			} else {
				if name != findName {
					continue
				}
			}
		}
		items = append(items, item)
	}
	count := int64(len(items))
	response = &grpc_user.FindResponse{
		Result: request.Result,
	}
	if request.Result == grpc_user.FindRequest_COUNT || request.Result == grpc_user.FindRequest_DATA_COUNT {
		response.Count = count
	}
	if request.Result == grpc_user.FindRequest_DATA || request.Result == grpc_user.FindRequest_DATA_COUNT {
		if request.Offset < count {
			sort.Sort(dataSortByID(items))

			offset := int(request.Offset)
			end := request.Offset + request.Limit
			if end > count {
				end = count
			}

			items = items[offset:end]
			if len(items) > 0 {
				response.Data = make([]*grpc_user.Data, len(items))
				for i, v := range items {
					response.Data[i] = v.ToPB()
				}
			}
		}
	}
	m.RUnlock()
	return
}{{/if}}

// Find .
func Find(request *grpc_user.FindRequest) (*grpc_user.FindResponse, error) {
{{if db}}{{else}}	return _management.Find(request){{/if}}
}